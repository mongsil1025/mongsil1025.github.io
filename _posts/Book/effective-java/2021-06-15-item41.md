---
title:  "[Effective Java] 아이템41 - 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라"
date: 2021-06-15
excerpt: ""
tags: [book, effective-java]
classes: wide
categories: [book/effective-java]
---

아이템39에서 **마커 애너테이션**에 대해 알아봤다. 비슷하게 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 **마커 인터페이스**라 한다. `Serializable` 인터페이스가 좋은 예다. `Serializable` 인터페이스를 구현한 클래스의 인스턴스는 `ObjectOutputStream`을 통해 write 할 수 있다(직렬화)는 것을 알 수 있다. (자세한 내용은 12장에서 살펴본다)

마커 인터페이스와 마커 애너테이션의 큰 차이점은 아래와 같다.
- 마커 애너테이션에 오류가 있다면 컴파일타임이 아닌 런타임에야 잡을 수 있지만, 마커 인터페이스는 컴파일타임에도 에러를 잡을 수 있다.
- 마커 인터페이스는 마커 애너테이션보다 적용 대상을 더 정밀하게 지정할 수 있다.
  - @Target을 ElementType.TYPE으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거타입, 애너테이션)에 달 수 있다. 하지만 마커 인터페이스는 특정 클래스에만 적용하고자 할 때 해당 클래스에만 제한할 수 있다.

마커를 클래스나 인터페이스에 적용해야 한다면 "이 마킹이 된 객체를 매개변수로 받는 **메서드**를 작성할 일이 있을까?" 라고 생각했을 때, "그렇다" 이면 마커 인터페이스를 써야 한다. 왜냐하면 해당 타입을 매개변수로 사용하여 컴파일타임에 오류를 잡아낼 수 있기 때문이다.

반대로 이런 메서드를 작성할 일이 없고, 보다 큰 범위인 프레임워크에서 활발히 사용하는 용도라면 마커 애너테이션이 좋다.

적용 대상이 ElementType.TYPE인 마커 애너테이션을 작성하고 있다면, 잠시 여유를 갖고 정말 애너테이션으로 구현하는 게 옳은지, 혹은 마커 인터페이스가 낫지는 않을지 곰곰이 생각해보자
{: .notice--info}

(12장 Serializable에 대한 내용을 읽어야 조금 더 이해가 갈 것 같다)
